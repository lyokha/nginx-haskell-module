/*
 * =============================================================================
 *
 *       Filename:  ngx_http_haskell_standalone.c
 *
 *    Description:  Standalone Haskell header and footer
 *
 *        Version:  2.0
 *        Created:  05.02.2018 12:18:56
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Alexey Radkov (), 
 *        Company:  
 *
 * =============================================================================
 */

#include "ngx_http_haskell_standalone.h"


const ngx_str_t  ngx_http_haskell_module_standalone_header =
ngx_string(
"{-# LANGUAGE ForeignFunctionInterface, InterruptibleFFI, CPP #-}\n"
"{-# OPTIONS_GHC -pgmPcpphs -optP--cpp #-}\n\n"

"#define AUX_NGX_TYPECHECK(T, F, S) \\\n"
"type_ngx_hs_ ## F = aux_ngx_exportType $ T S; \\\n"
"foreign export ccall type_ngx_hs_ ## F :: IO AUX_NGX.CInt;\n\n"

"#define AUX_NGX_AMBIGUITYCHECK(F, A) \\\n"
"ambiguity_ngx_hs_ ## F = aux_ngx_exportTypeAmbiguity A; \\\n"
"foreign export ccall ambiguity_ngx_hs_ ## F :: IO AUX_NGX.CInt;\n\n"

"#define NGX_EXPORT_S_S(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_S_S, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_s_s $ AUX_NGX_S_S F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_S_SS(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_S_SS, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_s_ss $ AUX_NGX_S_SS F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_S_LS(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_S_LS, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_s_ls $ AUX_NGX_S_LS F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_B_S(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_B_S, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_b_s $ AUX_NGX_B_S F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_B_SS(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_B_SS, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_b_ss $ AUX_NGX_B_SS F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_B_LS(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_B_LS, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_b_ls $ AUX_NGX_B_LS F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_Y_Y(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_Y_Y, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_Y_Y_SYNC) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_y_y $ AUX_NGX_Y_Y F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_B_Y(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_B_Y, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_b_y $ AUX_NGX_B_Y F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_IOY_Y(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_IOY_Y, F, (const . F)) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_IOY_Y_SYNC) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_ioy_y $ AUX_NGX_IOY_Y (const . F); \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_ASYNC_IOY_Y(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_IOY_Y, F, (const . F)) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_IOY_Y_ASYNC) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_async_ioy_y $ AUX_NGX_IOY_Y (const . F); \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> AUX_NGX.CUInt -> AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()));\n\n"

"#define NGX_EXPORT_ASYNC_ON_REQ_BODY(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_IOY_YY, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_async_ioy_yy $ AUX_NGX_IOY_YY F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()));\n\n"

"#define NGX_EXPORT_SERVICE_IOY_Y(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_IOY_Y, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_IOY_Y_ASYNC) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_async_ioy_y $ AUX_NGX_IOY_Y F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> AUX_NGX.CUInt -> AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()));\n\n"

"#define NGX_EXPORT_HANDLER(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_HANDLER, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_handler $ AUX_NGX_HANDLER F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_DEF_HANDLER(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_Y_Y, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_Y_Y_DEF_HANDLER) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_def_handler $ AUX_NGX_Y_Y F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> AUX_NGX.Ptr AUX_NGX.CString -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_UNSAFE_HANDLER(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_UNSAFE_HANDLER, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_unsafe_handler $ AUX_NGX_UNSAFE_HANDLER F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_ASYNC_HANDLER(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_ASYNC_HANDLER, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_async_handler $ AUX_NGX_ASYNC_HANDLER F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()));\n\n"

"#define NGX_EXPORT_ASYNC_HANDLER_ON_REQ_BODY(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_ASYNC_HANDLER_RB, F, F) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_UNAMBIGUOUS) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_async_handler_rb $ AUX_NGX_ASYNC_HANDLER_RB F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()));\n\n"

"#define NGX_EXPORT_SERVICE_HOOK(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_IOY_Y, F, (const . F)) \\\n"
"AUX_NGX_AMBIGUITYCHECK(F, AUX_NGX_IOY_Y_SYNC) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_ioy_y_with_free $ AUX_NGX_IOY_Y (const . F); \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"{-# LANGUAGE ViewPatterns, TupleSections #-}\n\n"

"module NgxHaskellUserRuntime where\n\n"

"-- requires packages base, cpphs, bytestring, async, binary, monad-loops, unix"
"\n\n"

"import qualified Foreign.C as AUX_NGX\n"
"import qualified Foreign.Ptr as AUX_NGX\n"
"import qualified Foreign.StablePtr as AUX_NGX\n"
"import qualified Foreign.Storable as AUX_NGX\n"
"import qualified Foreign.Marshal.Alloc as AUX_NGX\n"
"import qualified Foreign.Marshal.Utils as AUX_NGX\n"
"import qualified Data.IORef as AUX_NGX\n"
"import qualified System.IO.Unsafe as AUX_NGX\n"
"import qualified System.IO.Error as AUX_NGX\n"
"import qualified System.Posix.IO as AUX_NGX\n"
"import qualified System.Posix.Types as AUX_NGX\n"
"import qualified System.Posix.Signals as AUX_NGX\n"
"import qualified System.Posix.Internals as AUX_NGX\n"
"import qualified Control.Monad as AUX_NGX\n"
"import qualified Control.Monad.Loops as AUX_NGX\n"
"import qualified Control.DeepSeq as AUX_NGX\n"
"import qualified Control.Exception as AUX_NGX\n"
"import qualified GHC.IO.Exception as AUX_NGX\n"
"import qualified GHC.IO.Device as AUX_NGX\n"
"import qualified Control.Concurrent.Async as AUX_NGX\n"
"import qualified Data.ByteString as AUX_NGX_BS\n"
"import qualified Data.ByteString.Unsafe as AUX_NGX_BS\n"
"import qualified Data.ByteString.Lazy as AUX_NGX_BSL\n"
"import qualified Data.ByteString.Lazy.Char8 as AUX_NGX_BSLC8\n"
"import qualified Data.Binary.Put as AUX_NGX\n"
"import qualified Data.Bits as AUX_NGX\n\n"

"-- START OF USER HASKELL CODE\n"
);

const ngx_str_t  ngx_http_haskell_module_standalone_footer =
ngx_string(
"\n-- END OF USER HASKELL CODE\n\n"

"type ContentHandlerResult =\n"
"    (AUX_NGX_BSL.ByteString, AUX_NGX_BS.ByteString, Int, HTTPHeaders)\n"
"type UnsafeContentHandlerResult =\n"
"    (AUX_NGX_BS.ByteString, AUX_NGX_BS.ByteString, Int)\n"
"type HTTPHeaders =\n"
"    [(AUX_NGX_BS.ByteString, AUX_NGX_BS.ByteString)]\n\n"

"data AUX_NGX_EXPORT = AUX_NGX_S_S (String -> String)\n"
"                    | AUX_NGX_S_SS (String -> String -> String)\n"
"                    | AUX_NGX_S_LS ([String] -> String)\n"
"                    | AUX_NGX_B_S (String -> Bool)\n"
"                    | AUX_NGX_B_SS (String -> String -> Bool)\n"
"                    | AUX_NGX_B_LS ([String] -> Bool)\n"
"                    | AUX_NGX_Y_Y (AUX_NGX_BS.ByteString ->\n"
"                          AUX_NGX_BSL.ByteString)\n"
"                    | AUX_NGX_B_Y (AUX_NGX_BS.ByteString -> Bool)\n"
"                    | AUX_NGX_IOY_Y (AUX_NGX_BS.ByteString -> Bool ->\n"
"                          IO AUX_NGX_BSL.ByteString)\n"
"                    | AUX_NGX_IOY_YY (AUX_NGX_BSL.ByteString ->\n"
"                          AUX_NGX_BS.ByteString -> IO AUX_NGX_BSL.ByteString)"
"\n"
"                    | AUX_NGX_HANDLER (AUX_NGX_BS.ByteString ->\n"
"                          ContentHandlerResult)\n"
"                    | AUX_NGX_UNSAFE_HANDLER (AUX_NGX_BS.ByteString ->\n"
"                          UnsafeContentHandlerResult)\n"
"                    | AUX_NGX_ASYNC_HANDLER (AUX_NGX_BS.ByteString ->\n"
"                          IO ContentHandlerResult)\n"
"                    | AUX_NGX_ASYNC_HANDLER_RB (AUX_NGX_BSL.ByteString ->\n"
"                          AUX_NGX_BS.ByteString ->\n"
"                          IO ContentHandlerResult)\n\n"

"instance Enum AUX_NGX_EXPORT where\n"
"    toEnum _ = AUX_NGX_S_S id    -- not used\n"
"    fromEnum (AUX_NGX_S_S _)              = 1\n"
"    fromEnum (AUX_NGX_S_SS _)             = 2\n"
"    fromEnum (AUX_NGX_S_LS _)             = 3\n"
"    fromEnum (AUX_NGX_B_S _)              = 4\n"
"    fromEnum (AUX_NGX_B_SS _)             = 5\n"
"    fromEnum (AUX_NGX_B_LS _)             = 6\n"
"    fromEnum (AUX_NGX_Y_Y _)              = 7\n"
"    fromEnum (AUX_NGX_B_Y _)              = 8\n"
"    fromEnum (AUX_NGX_IOY_Y _)            = 9\n"
"    fromEnum (AUX_NGX_IOY_YY _)           = 10\n"
"    fromEnum (AUX_NGX_HANDLER _)          = 11\n"
"    fromEnum (AUX_NGX_UNSAFE_HANDLER _)   = 12\n"
"    fromEnum (AUX_NGX_ASYNC_HANDLER _)    = 13\n"
"    fromEnum (AUX_NGX_ASYNC_HANDLER_RB _) = 14\n\n"

"aux_ngx_exportType :: AUX_NGX_EXPORT -> IO AUX_NGX.CInt\n"
"aux_ngx_exportType = return . fromIntegral . fromEnum\n\n"

"data AUX_NGX_EXPORT_TYPE_AMBIGUITY_TAG = AUX_NGX_UNAMBIGUOUS\n"
"                                       | AUX_NGX_Y_Y_SYNC\n"
"                                       | AUX_NGX_Y_Y_DEF_HANDLER\n"
"                                       | AUX_NGX_IOY_Y_SYNC\n"
"                                       | AUX_NGX_IOY_Y_ASYNC\n\n"

"instance Enum AUX_NGX_EXPORT_TYPE_AMBIGUITY_TAG where\n"
"    toEnum _ = AUX_NGX_UNAMBIGUOUS    -- not used\n"
"    fromEnum AUX_NGX_UNAMBIGUOUS     = 0\n"
"    fromEnum AUX_NGX_Y_Y_SYNC        = 1\n"
"    fromEnum AUX_NGX_Y_Y_DEF_HANDLER = 2\n"
"    fromEnum AUX_NGX_IOY_Y_SYNC      = 3\n"
"    fromEnum AUX_NGX_IOY_Y_ASYNC     = 4\n\n"

"aux_ngx_exportTypeAmbiguity :: AUX_NGX_EXPORT_TYPE_AMBIGUITY_TAG ->\n"
"    IO AUX_NGX.CInt\n"
"aux_ngx_exportTypeAmbiguity = return . fromIntegral . fromEnum\n\n"

"data AUX_NGX_STR_TYPE = AUX_NGX_STR_TYPE AUX_NGX.CSize AUX_NGX.CString\n\n"

"instance AUX_NGX.Storable AUX_NGX_STR_TYPE where\n"
"    alignment = const $ max (AUX_NGX.alignment (undefined :: AUX_NGX.CSize))\n"
"                            (AUX_NGX.alignment (undefined :: AUX_NGX.CString))"
"\n"
"    sizeOf = (2 *) . AUX_NGX.alignment   -- must always be correct for\n"
"                                         -- aligned struct ngx_str_t\n"
"    peek p = do\n"
"        n <- AUX_NGX.peekByteOff p 0\n"
"        s <- AUX_NGX.peekByteOff p $\n"
"            AUX_NGX.alignment (undefined :: AUX_NGX_STR_TYPE)\n"
"        return $ AUX_NGX_STR_TYPE n s\n"
"    poke p x@(AUX_NGX_STR_TYPE n s) = do\n"
"        AUX_NGX.poke (AUX_NGX.castPtr p) n\n"
"        AUX_NGX.poke (AUX_NGX.plusPtr p $ AUX_NGX.alignment x) s\n\n"

"data AUX_NGX_ServiceHookInterrupt = AUX_NGX_ServiceHookInterrupt\n\n"

"instance AUX_NGX.Exception AUX_NGX_ServiceHookInterrupt\n"
"instance Show AUX_NGX_ServiceHookInterrupt where\n"
"    show = const \"Service was interrupted by a service hook\"\n\n"

"newtype TerminateWorkerProcess = TerminateWorkerProcess String deriving Eq\n\n"

"instance AUX_NGX.Exception TerminateWorkerProcess\n"
"instance Show TerminateWorkerProcess where\n"
"    show (TerminateWorkerProcess s) = s\n\n"

"newtype RestartWorkerProcess = RestartWorkerProcess String deriving Eq\n\n"

"instance AUX_NGX.Exception RestartWorkerProcess\n"
"instance Show RestartWorkerProcess where\n"
"    show (RestartWorkerProcess s) = s\n\n"

"data WorkerProcessIsExiting = AUX_NGX_WorkerProcessIsExiting\n"
"    deriving (Show, Eq)\n\n"

"instance AUX_NGX.Exception WorkerProcessIsExiting where\n"
"  fromException = AUX_NGX.asyncExceptionFromException\n"
"  toException = AUX_NGX.asyncExceptionToException\n\n"

"data FinalizeHTTPRequest = FinalizeHTTPRequest Int (Maybe String) deriving Eq"
"\n\n"

"instance AUX_NGX.Exception FinalizeHTTPRequest\n"
"instance Show FinalizeHTTPRequest where\n"
"    show (FinalizeHTTPRequest _ (Just s)) = s\n"
"    show (FinalizeHTTPRequest _ Nothing) = \"\"\n\n"

"aux_ngx_safeMallocBytes :: Int -> IO (AUX_NGX.Ptr a)\n"
"aux_ngx_safeMallocBytes =\n"
"    flip AUX_NGX.catchIOError (const $ return AUX_NGX.nullPtr) .\n"
"        AUX_NGX.mallocBytes\n"
"{-# INLINE aux_ngx_safeMallocBytes #-}\n\n"

"aux_ngx_safeNewCStringLen :: String -> IO AUX_NGX.CStringLen\n"
"aux_ngx_safeNewCStringLen =\n"
"    flip AUX_NGX.catchIOError (const $ return (AUX_NGX.nullPtr, -1)) .\n"
"        AUX_NGX.newCStringLen\n"
"{-# INLINE aux_ngx_safeNewCStringLen #-}\n\n"

"aux_ngx_peekNgxStringArrayLen :: (AUX_NGX.CStringLen -> IO a) ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int -> IO [a]\n"
"aux_ngx_peekNgxStringArrayLen f x = sequence .\n"
"    foldr (\\k ->\n"
"            ((AUX_NGX.peekElemOff x k >>=\n"
"                (\\(AUX_NGX_STR_TYPE (fromIntegral -> m) y) -> f (y, m))) :)\n"
"          ) [] . flip take [0 ..]\n"
"{-# SPECIALIZE INLINE aux_ngx_peekNgxStringArrayLen ::\n"
"    (AUX_NGX.CStringLen -> IO String) ->\n"
"        AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int -> IO [String] #-}\n"
"{-# SPECIALIZE INLINE aux_ngx_peekNgxStringArrayLen ::\n"
"    (AUX_NGX.CStringLen -> IO AUX_NGX_BS.ByteString) ->\n"
"        AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int -> IO [AUX_NGX_BS.ByteString] #-}"
"\n\n"

"aux_ngx_peekNgxStringArrayLenLS :: AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int ->\n"
"    IO [String]\n"
"aux_ngx_peekNgxStringArrayLenLS =\n"
"    aux_ngx_peekNgxStringArrayLen AUX_NGX.peekCStringLen\n\n"

"aux_ngx_peekNgxStringArrayLenY :: AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int ->\n"
"    IO AUX_NGX_BSL.ByteString\n"
"aux_ngx_peekNgxStringArrayLenY =\n"
"    (fmap AUX_NGX_BSL.fromChunks .) .\n"
"        aux_ngx_peekNgxStringArrayLen AUX_NGX_BS.unsafePackCStringLen\n\n"

"aux_ngx_pokeCStringLen :: AUX_NGX.Storable a =>\n"
"    AUX_NGX.CString -> a -> AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr a ->\n"
"    IO ()\n"
"aux_ngx_pokeCStringLen x n p s = AUX_NGX.poke p x >> AUX_NGX.poke s n\n"
"{-# SPECIALIZE INLINE aux_ngx_pokeCStringLen ::\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.Ptr AUX_NGX.CString ->\n"
"        AUX_NGX.Ptr AUX_NGX.CInt -> IO () #-}\n"
"{-# SPECIALIZE INLINE aux_ngx_pokeCStringLen ::\n"
"    AUX_NGX.CString -> AUX_NGX.CSize -> AUX_NGX.Ptr AUX_NGX.CString ->\n"
"        AUX_NGX.Ptr AUX_NGX.CSize -> IO () #-}\n\n"

"aux_ngx_toBuffers :: AUX_NGX_BSL.ByteString -> AUX_NGX.Ptr AUX_NGX_STR_TYPE ->"
"\n"
"    IO (AUX_NGX.Ptr AUX_NGX_STR_TYPE, Int)\n"
"aux_ngx_toBuffers (AUX_NGX_BSL.null -> True) _ =\n"
"    return (AUX_NGX.nullPtr, 0)\n"
"aux_ngx_toBuffers s p = do\n"
"    let n = AUX_NGX_BSL.foldlChunks (const . succ) 0 s\n"
"    if n == 1 && p /= AUX_NGX.nullPtr\n"
"        then do\n"
"            AUX_NGX_BS.unsafeUseAsCStringLen (head $ AUX_NGX_BSL.toChunks s) $"
"\n"
"                \\(x, fromIntegral -> l) ->\n"
"                    AUX_NGX.poke p $ AUX_NGX_STR_TYPE l x\n"
"            return (p, 1)\n"
"        else do\n"
"            t <- aux_ngx_safeMallocBytes $\n"
"                n * AUX_NGX.sizeOf (undefined :: AUX_NGX_STR_TYPE)\n"
"            if t == AUX_NGX.nullPtr\n"
"                then return (AUX_NGX.nullPtr, -1)\n"
"                else (t ,) <$>\n"
"                        AUX_NGX_BSL.foldlChunks\n"
"                            (\\a c -> do\n"
"                                off <- a\n"
"                                AUX_NGX_BS.unsafeUseAsCStringLen c $\n"
"                                    \\(x, fromIntegral -> l) ->\n"
"                                        AUX_NGX.pokeElemOff t off $\n"
"                                            AUX_NGX_STR_TYPE l x\n"
"                                return $ off + 1\n"
"                            ) (return 0) s\n\n"

"aux_ngx_pokeLazyByteString :: AUX_NGX_BSL.ByteString ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> IO ()\n"
"aux_ngx_pokeLazyByteString s p pl spd = do\n"
"    pv <- AUX_NGX.peek p\n"
"    (t, fromIntegral -> l) <- aux_ngx_toBuffers s pv\n"
"    AUX_NGX.when (l /= 1 || pv == AUX_NGX.nullPtr) (AUX_NGX.poke p t) >>\n"
"        AUX_NGX.poke pl l\n"
"    AUX_NGX.when (t /= AUX_NGX.nullPtr) $\n"
"        AUX_NGX.newStablePtr s >>= AUX_NGX.poke spd\n\n"

"aux_ngx_pokeContentTypeAndStatus :: AUX_NGX_BS.ByteString ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> AUX_NGX.CInt -> IO AUX_NGX.CSize\n"
"aux_ngx_pokeContentTypeAndStatus ct pct plct pst st = do\n"
"    (sct, fromIntegral -> lct) <-\n"
"        AUX_NGX_BS.unsafeUseAsCStringLen ct return\n"
"    aux_ngx_pokeCStringLen sct lct pct plct >> AUX_NGX.poke pst st\n"
"    return lct\n\n"

"aux_ngx_peekRequestBodyChunks :: AUX_NGX.Ptr AUX_NGX_STR_TYPE ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int -> IO AUX_NGX_BSL.ByteString\n"
"aux_ngx_peekRequestBodyChunks tmpf b m =\n"
"    if tmpf /= AUX_NGX.nullPtr\n"
"        then do\n"
"            c <- AUX_NGX.peek tmpf >>=\n"
"                (\\(AUX_NGX_STR_TYPE (fromIntegral -> l) s) ->\n"
"                    AUX_NGX.peekCStringLen (s, l)) >>=\n"
"                        AUX_NGX_BSL.readFile\n"
"            AUX_NGX_BSL.length c `seq` return c\n"
"        else aux_ngx_peekNgxStringArrayLenY b m\n\n"

"aux_ngx_pokeAsyncHandlerData :: AUX_NGX_BS.ByteString ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> AUX_NGX.CInt -> HTTPHeaders ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> IO ()\n"
"aux_ngx_pokeAsyncHandlerData ct pct plct spct pst st rhs prhs plrhs sprhs = do"
"\n"
"    lct <- aux_ngx_pokeContentTypeAndStatus ct pct plct pst st\n"
"    AUX_NGX.when (lct > 0) $ AUX_NGX.newStablePtr ct >>= AUX_NGX.poke spct\n"
"    aux_ngx_pokeLazyByteString (aux_ngx_fromHTTPHeaders rhs) prhs plrhs sprhs"
"\n\n"

"aux_ngx_safeHandler :: AUX_NGX.Ptr AUX_NGX.CString ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> IO AUX_NGX.CUInt -> IO AUX_NGX.CUInt\n"
"aux_ngx_safeHandler p pl = AUX_NGX.handle $ \\e -> do\n"
"    (x, fromIntegral -> l) <- aux_ngx_safeNewCStringLen $\n"
"        show (e :: AUX_NGX.SomeException)\n"
"    aux_ngx_pokeCStringLen x l p pl\n"
"    return 1\n\n"

"aux_ngx_safeYYHandler :: IO (AUX_NGX_BSL.ByteString, AUX_NGX.CUInt) ->\n"
"    IO (AUX_NGX_BSL.ByteString, AUX_NGX.CUInt)\n"
"aux_ngx_safeYYHandler = AUX_NGX.handle $ \\e ->\n"
"    return (AUX_NGX_BSLC8.pack $ show (e :: AUX_NGX.SomeException), 1)\n"
"{-# INLINE aux_ngx_safeYYHandler #-}\n\n"

"aux_ngx_safeAsyncYYHandler ::\n"
"    IO (AUX_NGX_BSL.ByteString, (AUX_NGX.CUInt, Bool)) ->\n"
"    IO (AUX_NGX_BSL.ByteString, (AUX_NGX.CUInt, Bool))\n"
"aux_ngx_safeAsyncYYHandler = AUX_NGX.handle $ \\e ->\n"
"    return (AUX_NGX_BSLC8.pack $ show e,\n"
"            (case AUX_NGX.fromException e of\n"
"                Just AUX_NGX_ServiceHookInterrupt -> 2\n"
"                _ -> case AUX_NGX.fromException e of\n"
"                    Just (TerminateWorkerProcess _) -> 3\n"
"                    _ -> case AUX_NGX.fromException e of\n"
"                        Just (RestartWorkerProcess _) -> 4\n"
"                        _ -> case AUX_NGX.fromException e of\n"
"                            Just (FinalizeHTTPRequest st (Just _)) ->\n"
"                                0x80000000 AUX_NGX..|. fromIntegral st\n"
"                            Just (FinalizeHTTPRequest st Nothing) ->\n"
"                                0xC0000000 AUX_NGX..|. fromIntegral st\n"
"                            _ -> 1\n"
"            ,case AUX_NGX.asyncExceptionFromException e of\n"
"                Just AUX_NGX_WorkerProcessIsExiting -> True\n"
"                _ -> False\n"
"            )\n"
"           )\n"
"{-# INLINE aux_ngx_safeAsyncYYHandler #-}\n\n"

"aux_ngx_fromHTTPHeaders :: HTTPHeaders -> AUX_NGX_BSL.ByteString\n"
"aux_ngx_fromHTTPHeaders =\n"
"    AUX_NGX_BSL.fromChunks . foldr (\\(z -> a, z -> b) -> ([a, b] ++)) []\n"
"    where z s | AUX_NGX_BS.null s = AUX_NGX_BS.singleton 0\n"
"              | otherwise = s\n\n"

"aux_ngx_isEINTR :: AUX_NGX.IOError -> Bool\n"
"aux_ngx_isEINTR =\n"
"    (Just ((\\(AUX_NGX.Errno i) -> i) AUX_NGX.eINTR) ==) . AUX_NGX.ioe_errno\n"
"{-# INLINE aux_ngx_isEINTR #-}\n\n"

"aux_ngx_hs_s_s :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_s_s (AUX_NGX_S_S f)\n"
"            x (fromIntegral -> n) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        (s, fromIntegral -> l) <- f <$> AUX_NGX.peekCStringLen (x, n)\n"
"                                    >>= AUX_NGX.newCStringLen\n"
"        aux_ngx_pokeCStringLen s l p pl\n"
"        return 0\n\n"

"aux_ngx_hs_s_ss :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_s_ss (AUX_NGX_S_SS f)\n"
"            x (fromIntegral -> n) y (fromIntegral -> m) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        (s, fromIntegral -> l) <- f <$> AUX_NGX.peekCStringLen (x, n)\n"
"                                    <*> AUX_NGX.peekCStringLen (y, m)\n"
"                                    >>= AUX_NGX.newCStringLen\n"
"        aux_ngx_pokeCStringLen s l p pl\n"
"        return 0\n\n"

"aux_ngx_hs_s_ls :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_s_ls (AUX_NGX_S_LS f)\n"
"            x (fromIntegral -> n) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        (s, fromIntegral -> l) <- f <$> aux_ngx_peekNgxStringArrayLenLS x n\n"
"                                    >>= AUX_NGX.newCStringLen\n"
"        aux_ngx_pokeCStringLen s l p pl\n"
"        return 0\n\n"

"aux_ngx_hs_y_y :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_y_y (AUX_NGX_Y_Y f)\n"
"            x (fromIntegral -> n) p pl spd = do\n"
"    (s, r) <- aux_ngx_safeYYHandler $ do\n"
"        s <- f <$> AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        fmap (, 0) $ return AUX_NGX.$!! s\n"
"    aux_ngx_pokeLazyByteString s p pl spd\n"
"    return r\n\n"

"aux_ngx_hs_ioy_y_common :: (AUX_NGX.CStringLen -> IO AUX_NGX_BS.ByteString) ->"
"\n"
"    AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_ioy_y_common aux_ngx_pack (AUX_NGX_IOY_Y f)\n"
"            x (fromIntegral -> n) p pl spd = do\n"
"    (s, r) <- aux_ngx_safeYYHandler $ do\n"
"        s <- aux_ngx_pack (x, n) >>= flip f False\n"
"        fmap (, 0) $ return AUX_NGX.$!! s\n"
"    aux_ngx_pokeLazyByteString s p pl spd\n"
"    return r\n\n"

"aux_ngx_hs_ioy_y :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_ioy_y =\n"
"    aux_ngx_hs_ioy_y_common AUX_NGX_BS.unsafePackCStringLen\n\n"

"aux_ngx_hs_ioy_y_with_free :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_ioy_y_with_free =\n"
"    aux_ngx_hs_ioy_y_common AUX_NGX_BS.unsafePackMallocCStringLen\n\n"

"aux_ngx_asyncIOFlag1b :: AUX_NGX_BS.ByteString\n"
"aux_ngx_asyncIOFlag1b =\n"
"    AUX_NGX_BSL.toStrict $ AUX_NGX.runPut $ AUX_NGX.putWord8 1\n\n"

"aux_ngx_asyncIOFlag8b :: AUX_NGX_BS.ByteString\n"
"aux_ngx_asyncIOFlag8b =\n"
"    AUX_NGX_BSL.toStrict $ AUX_NGX.runPut $ AUX_NGX.putWord64host 1\n\n"

"aux_ngx_asyncIOCommon :: IO (AUX_NGX_BSL.ByteString, Bool) ->\n"
"    AUX_NGX.CInt -> Bool -> AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> AUX_NGX.Ptr AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()))\n"
"aux_ngx_asyncIOCommon a (fromIntegral -> fd) efd p pl pr spd =\n"
"    AUX_NGX.mask $ \\restore -> AUX_NGX.async\n"
"    (do\n"
"        (s, (r, exiting)) <- aux_ngx_safeAsyncYYHandler $\n"
"            restore $ do\n"
"                (s, exiting) <- a\n"
"                fmap (, (0, exiting)) $ return AUX_NGX.$!! s\n"
"        aux_ngx_pokeLazyByteString s p pl spd\n"
"        AUX_NGX.poke pr r\n"
"        if exiting\n"
"            then AUX_NGX.unless efd closeChannel\n"
"            else AUX_NGX.uninterruptibleMask_ $\n"
"                    if efd\n"
"                        then writeFlag8b\n"
"                        else writeFlag1b >> closeChannel\n"
"    ) >>= AUX_NGX.newStablePtr\n"
"    where writeBufN n s =\n"
"              AUX_NGX.iterateUntilM (>= n)\n"
"              (\\w -> (w +) <$>\n"
"                  AUX_NGX.fdWriteBuf fd (AUX_NGX.plusPtr s $ fromIntegral w)\n"
"                      (n - w)\n"
"                  `AUX_NGX.catchIOError`\n"
"                  (\\e -> return $ if aux_ngx_isEINTR e\n"
"                                      then 0\n"
"                                      else n + 1\n"
"                  )\n"
"              ) 0 >>= \\w -> AUX_NGX.when (w > n) cleanupOnWriteError\n"
"          writeFlag1b =\n"
"              AUX_NGX_BS.unsafeUseAsCString aux_ngx_asyncIOFlag1b $ writeBufN "
"1\n"
"          writeFlag8b =\n"
"              AUX_NGX_BS.unsafeUseAsCString aux_ngx_asyncIOFlag8b $ writeBufN "
"8\n"
"          closeChannel =\n"
"              AUX_NGX.closeFd fd `AUX_NGX.catchIOError` const (return ())\n"
"          -- FIXME: cleanupOnWriteError should free all previously allocated\n"
"          -- data and stable pointers. However, leaving this not implemented\n"
"          -- seems to be safe because Nginx won't close the event channel or\n"
"          -- delete the request object (for request-driven handlers)\n"
"          -- regardless of the Haskell handler's duration.\n"
"          cleanupOnWriteError = return ()\n\n"

"aux_ngx_hs_async_ioy_y :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> AUX_NGX.CUInt -> AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()))\n"
"aux_ngx_hs_async_ioy_y (AUX_NGX_IOY_Y f)\n"
"            x (fromIntegral -> n) fd (fromIntegral -> fdlk) active\n"
"            (AUX_NGX.toBool -> efd) (AUX_NGX.toBool -> fstRun) =\n"
"    aux_ngx_asyncIOCommon\n"
"    (do\n"
"        exiting <- if fstRun && fdlk /= -1\n"
"                       then snd <$>\n"
"                           AUX_NGX.iterateUntil ((True ==) . fst)\n"
"                           (aux_ngx_safeWaitToSetLock fdlk\n"
"                                (AUX_NGX.WriteLock, AUX_NGX.AbsoluteSeek,\n"
"                                     0, 0) >> return (True, False)\n"
"                           )\n"
"                           `AUX_NGX.catches`\n"
"                           [AUX_NGX.Handler $\n"
"                                return . (, False) . not . aux_ngx_isEINTR\n"
"                           ,AUX_NGX.Handler $\n"
"                                return . (True, ) .\n"
"                                    (== AUX_NGX_WorkerProcessIsExiting)\n"
"                           ]\n"
"                       else return False\n"
"        if exiting\n"
"            then return (AUX_NGX_BSL.empty, True)\n"
"            else do\n"
"                AUX_NGX.when fstRun $ AUX_NGX.poke active 1\n"
"                x' <- AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"                (, False) <$> f x' fstRun\n"
"    ) fd efd\n\n"

"aux_ngx_hs_async_ioy_yy :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> AUX_NGX.Ptr AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()))\n"
"aux_ngx_hs_async_ioy_yy (AUX_NGX_IOY_YY f)\n"
"            tmpf b (fromIntegral -> m) x (fromIntegral -> n)\n"
"            fd (AUX_NGX.toBool -> efd) =\n"
"    aux_ngx_asyncIOCommon\n"
"    (do\n"
"        b' <- aux_ngx_peekRequestBodyChunks tmpf b m\n"
"        x' <- AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        (, False) <$> f b' x'\n"
"    ) fd efd\n\n"

"aux_ngx_hs_async_handler :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()))\n"
"aux_ngx_hs_async_handler (AUX_NGX_ASYNC_HANDLER f)\n"
"            x (fromIntegral -> n) fd (AUX_NGX.toBool -> efd)\n"
"            pct plct spct pst prhs plrhs sprhs =\n"
"    aux_ngx_asyncIOCommon\n"
"    (do\n"
"        x' <- AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        v@(s, ct, fromIntegral -> st, rhs) <- f x'\n"
"        (return AUX_NGX.$!! v) >>\n"
"            AUX_NGX.mask_\n"
"                (aux_ngx_pokeAsyncHandlerData ct pct plct spct pst st\n"
"                    rhs prhs plrhs sprhs\n"
"                )\n"
"        return (s, False)\n"
"    ) fd efd\n\n"

"aux_ngx_hs_async_handler_rb :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()))\n"
"aux_ngx_hs_async_handler_rb (AUX_NGX_ASYNC_HANDLER_RB f)\n"
"            tmpf b (fromIntegral -> m) x (fromIntegral -> n)\n"
"            fd (AUX_NGX.toBool -> efd)\n"
"            pct plct spct pst prhs plrhs sprhs =\n"
"    aux_ngx_asyncIOCommon\n"
"    (do\n"
"        b' <- aux_ngx_peekRequestBodyChunks tmpf b m\n"
"        x' <- AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        v@(s, ct, fromIntegral -> st, rhs) <- f b' x'\n"
"        (return AUX_NGX.$!! v) >>\n"
"            AUX_NGX.mask_\n"
"                (aux_ngx_pokeAsyncHandlerData ct pct plct spct pst st\n"
"                    rhs prhs plrhs sprhs\n"
"                )\n"
"        return (s, False)\n"
"    ) fd efd\n\n"

"aux_ngx_hs_b_s :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_b_s (AUX_NGX_B_S f)\n"
"            x (fromIntegral -> n) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        r <- AUX_NGX.fromBool . f <$> AUX_NGX.peekCStringLen (x, n)\n"
"        aux_ngx_pokeCStringLen AUX_NGX.nullPtr 0 p pl\n"
"        return r\n\n"

"aux_ngx_hs_b_ss :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_b_ss (AUX_NGX_B_SS f)\n"
"            x (fromIntegral -> n) y (fromIntegral -> m) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        r <- (AUX_NGX.fromBool .) . f <$> AUX_NGX.peekCStringLen (x, n)\n"
"                                      <*> AUX_NGX.peekCStringLen (y, m)\n"
"        aux_ngx_pokeCStringLen AUX_NGX.nullPtr 0 p pl\n"
"        return r\n\n"

"aux_ngx_hs_b_ls :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_b_ls (AUX_NGX_B_LS f)\n"
"            x (fromIntegral -> n) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        r <- AUX_NGX.fromBool . f <$> aux_ngx_peekNgxStringArrayLenLS x n\n"
"        aux_ngx_pokeCStringLen AUX_NGX.nullPtr 0 p pl\n"
"        return r\n\n"

"aux_ngx_hs_b_y :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_b_y (AUX_NGX_B_Y f)\n"
"            x (fromIntegral -> n) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        r <- AUX_NGX.fromBool . f <$> AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        aux_ngx_pokeCStringLen AUX_NGX.nullPtr 0 p pl\n"
"        return r\n\n"

"aux_ngx_hs_handler :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_handler (AUX_NGX_HANDLER f)\n"
"            x (fromIntegral -> n) p pl pct plct spct pst\n"
"            prhs plrhs sprhs spd =\n"
"    aux_ngx_safeHandler pct pst $ do\n"
"        v@(s, ct, fromIntegral -> st, rhs) <-\n"
"            f <$> AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        lct <- (return AUX_NGX.$!! v) >>\n"
"            aux_ngx_pokeContentTypeAndStatus ct pct plct pst st\n"
"        (return AUX_NGX.$!! lct) >>\n"
"            aux_ngx_pokeLazyByteString (aux_ngx_fromHTTPHeaders rhs)\n"
"                prhs plrhs sprhs\n"
"        aux_ngx_pokeLazyByteString s p pl spd\n"
"        AUX_NGX.when (lct > 0) $ AUX_NGX.newStablePtr ct >>= AUX_NGX.poke spct"
"\n"
"        return 0\n\n"

"aux_ngx_hs_def_handler :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr AUX_NGX.CString ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_def_handler (AUX_NGX_Y_Y f)\n"
"            x (fromIntegral -> n) p pl pe spd =\n"
"    aux_ngx_safeHandler pe pl $ do\n"
"        s <- f <$> AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        aux_ngx_pokeLazyByteString s p pl spd\n"
"        return 0\n\n"

"aux_ngx_hs_unsafe_handler :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> IO AUX_NGX.CUInt\n"
"aux_ngx_hs_unsafe_handler (AUX_NGX_UNSAFE_HANDLER f)\n"
"            x (fromIntegral -> n) p pl pct plct pst =\n"
"    aux_ngx_safeHandler pct pst $ do\n"
"        v@(s, ct, fromIntegral -> st) <-\n"
"            f <$> AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        (return AUX_NGX.$!! v) >>\n"
"            AUX_NGX.void (aux_ngx_pokeContentTypeAndStatus ct pct plct pst st)"
"\n"
"        (t, fromIntegral -> l) <- AUX_NGX_BS.unsafeUseAsCStringLen s return\n"
"        aux_ngx_pokeCStringLen t l p pl\n"
"        return 0\n\n"

"{- SPLICE: safe version of waitToSetLock as defined in System.Posix.IO -}\n\n"

"foreign import ccall interruptible \"HsBase.h fcntl\"\n"
"    aux_ngx_safe_c_fcntl_lock :: AUX_NGX.CInt -> AUX_NGX.CInt ->\n"
"        AUX_NGX.Ptr AUX_NGX.CFLock -> IO AUX_NGX.CInt\n\n"

"aux_ngx_mode2Int :: AUX_NGX.SeekMode -> AUX_NGX.CShort\n"
"aux_ngx_mode2Int AUX_NGX.AbsoluteSeek = 0\n"
"aux_ngx_mode2Int AUX_NGX.RelativeSeek = 1\n"
"aux_ngx_mode2Int AUX_NGX.SeekFromEnd  = 2\n\n"

"aux_ngx_lockReq2Int :: AUX_NGX.LockRequest -> AUX_NGX.CShort\n"
"aux_ngx_lockReq2Int AUX_NGX.ReadLock  = 0\n"
"aux_ngx_lockReq2Int AUX_NGX.WriteLock = 1\n"
"aux_ngx_lockReq2Int AUX_NGX.Unlock    = 2\n\n"

"aux_ngx_allocaLock :: AUX_NGX.FileLock ->\n"
"    (AUX_NGX.Ptr AUX_NGX.CFLock -> IO a) -> IO a\n"
"aux_ngx_allocaLock (lockreq, mode, start, len) io =\n"
"    AUX_NGX.allocaBytes 32 $ \\p -> do\n"
"        (`AUX_NGX.pokeByteOff`  0) p (aux_ngx_lockReq2Int lockreq)\n"
"        (`AUX_NGX.pokeByteOff`  2) p (aux_ngx_mode2Int mode)\n"
"        (`AUX_NGX.pokeByteOff`  8) p start\n"
"        (`AUX_NGX.pokeByteOff` 16) p len\n"
"        io p\n\n"

"aux_ngx_safeWaitToSetLock :: AUX_NGX.Fd -> AUX_NGX.FileLock -> IO ()\n"
"aux_ngx_safeWaitToSetLock (AUX_NGX.Fd fd) lock = aux_ngx_allocaLock lock $\n"
"    \\p_flock -> AUX_NGX.throwErrnoIfMinus1_ \"safeWaitToSetLock\" $\n"
"        aux_ngx_safe_c_fcntl_lock fd 7 p_flock\n\n"

"{- SPLICE: END -}\n\n"

"foreign export ccall ngxExportInstallSignalHandler :: IO ()\n"
"ngxExportInstallSignalHandler :: IO ()\n"
"ngxExportInstallSignalHandler = AUX_NGX.void $\n"
"    AUX_NGX.installHandler AUX_NGX.keyboardSignal AUX_NGX.Ignore Nothing\n\n"

"foreign export ccall ngxExportTerminateTask ::\n"
"    AUX_NGX.StablePtr (AUX_NGX.Async ()) -> IO ()\n"
"ngxExportTerminateTask ::\n"
"    AUX_NGX.StablePtr (AUX_NGX.Async ()) -> IO ()\n"
"ngxExportTerminateTask =\n"
"    AUX_NGX.deRefStablePtr AUX_NGX.>=>\n"
"        flip AUX_NGX.cancelWith AUX_NGX_WorkerProcessIsExiting\n\n"

"foreign export ccall ngxExportServiceHookInterrupt ::\n"
"    AUX_NGX.StablePtr (AUX_NGX.Async ()) -> IO ()\n"
"ngxExportServiceHookInterrupt ::\n"
"    AUX_NGX.StablePtr (AUX_NGX.Async ()) -> IO ()\n"
"ngxExportServiceHookInterrupt =\n"
"    AUX_NGX.deRefStablePtr AUX_NGX.>=>\n"
"        flip AUX_NGX.throwTo AUX_NGX_ServiceHookInterrupt .\n"
"            AUX_NGX.asyncThreadId\n\n"

"ngxCyclePtr :: IO (AUX_NGX.Ptr ())\n"
"ngxCyclePtr = AUX_NGX.readIORef aux_ngx_ngxCyclePtrStore\n\n"

"ngxUpstreamMainConfPtr :: IO (AUX_NGX.Ptr ())\n"
"ngxUpstreamMainConfPtr = AUX_NGX.readIORef aux_ngx_ngxUpstreamMainConfPtrStore"
"\n\n"

"ngxCachedTimePtr :: IO (AUX_NGX.Ptr (AUX_NGX.Ptr ()))\n"
"ngxCachedTimePtr = AUX_NGX.readIORef aux_ngx_ngxCachedTimePtrStore\n\n"

"foreign export ccall ngxExportSetCyclePtr ::\n"
"    AUX_NGX.Ptr () -> IO ()\n"
"ngxExportSetCyclePtr :: AUX_NGX.Ptr () -> IO ()\n"
"ngxExportSetCyclePtr = AUX_NGX.writeIORef aux_ngx_ngxCyclePtrStore\n\n"

"foreign export ccall ngxExportSetUpstreamMainConfPtr ::\n"
"    AUX_NGX.Ptr () -> IO ()\n"
"ngxExportSetUpstreamMainConfPtr :: AUX_NGX.Ptr () -> IO ()\n"
"ngxExportSetUpstreamMainConfPtr =\n"
"    AUX_NGX.writeIORef aux_ngx_ngxUpstreamMainConfPtrStore\n\n"

"foreign export ccall ngxExportSetCachedTimePtr ::\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr ()) -> IO ()\n"
"ngxExportSetCachedTimePtr :: AUX_NGX.Ptr (AUX_NGX.Ptr ()) -> IO ()\n"
"ngxExportSetCachedTimePtr = AUX_NGX.writeIORef aux_ngx_ngxCachedTimePtrStore"
"\n\n"

"aux_ngx_ngxCyclePtrStore :: AUX_NGX.IORef (AUX_NGX.Ptr ())\n"
"aux_ngx_ngxCyclePtrStore =\n"
"    AUX_NGX.unsafePerformIO $ AUX_NGX.newIORef AUX_NGX.nullPtr\n"
"{-# NOINLINE aux_ngx_ngxCyclePtrStore #-}\n\n"

"aux_ngx_ngxUpstreamMainConfPtrStore :: AUX_NGX.IORef (AUX_NGX.Ptr ())\n"
"aux_ngx_ngxUpstreamMainConfPtrStore =\n"
"    AUX_NGX.unsafePerformIO $ AUX_NGX.newIORef AUX_NGX.nullPtr\n"
"{-# NOINLINE aux_ngx_ngxUpstreamMainConfPtrStore #-}\n\n"

"aux_ngx_ngxCachedTimePtrStore :: AUX_NGX.IORef (AUX_NGX.Ptr (AUX_NGX.Ptr ()))"
"\n"
"aux_ngx_ngxCachedTimePtrStore =\n"
"    AUX_NGX.unsafePerformIO $ AUX_NGX.newIORef AUX_NGX.nullPtr\n"
"{-# NOINLINE aux_ngx_ngxCachedTimePtrStore #-}\n\n"
);

