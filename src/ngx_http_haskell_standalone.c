/*
 * =============================================================================
 *
 *       Filename:  ngx_http_haskell_standalone.c
 *
 *    Description:  standalone Haskell header and footer
 *
 *        Version:  1.0
 *        Created:  05.02.2018 12:18:56
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Alexey Radkov (), 
 *        Company:  
 *
 * =============================================================================
 */

#include "ngx_http_haskell_standalone.h"


const ngx_str_t  ngx_http_haskell_module_standalone_header =
ngx_string(
"{-# LANGUAGE ForeignFunctionInterface, InterruptibleFFI, CPP #-}\n"
"{-# OPTIONS_GHC -pgmPcpphs -optP--cpp #-}\n\n"

"#define AUX_NGX_TYPECHECK(T, F, S) \\\n"
"type_ngx_hs_ ## F = aux_ngx_exportType $ T S; \\\n"
"foreign export ccall type_ngx_hs_ ## F :: IO AUX_NGX.CInt;\n\n"

"#define NGX_EXPORT_S_S(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_S_S, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_s_s $ AUX_NGX_S_S F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_S_SS(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_S_SS, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_s_ss $ AUX_NGX_S_SS F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_S_LS(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_S_LS, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_s_ls $ AUX_NGX_S_LS F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_B_S(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_B_S, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_b_s $ AUX_NGX_B_S F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_B_SS(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_B_SS, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_b_ss $ AUX_NGX_B_SS F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_B_LS(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_B_LS, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_b_ls $ AUX_NGX_B_LS F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_Y_Y(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_Y_Y, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_y_y $ AUX_NGX_Y_Y F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_B_Y(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_B_Y, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_b_y $ AUX_NGX_B_Y F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_IOY_Y(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_IOY_Y, F, (const . F)) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_ioy_y $ AUX_NGX_IOY_Y (const . F); \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_ASYNC_IOY_Y(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_IOY_Y, F, (const . F)) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_async_ioy_y $ AUX_NGX_IOY_Y (const . F); \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> AUX_NGX.CUInt -> AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()));\n\n"

"#define NGX_EXPORT_ASYNC_ON_REQ_BODY(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_IOY_YY, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_async_ioy_yy $ AUX_NGX_IOY_YY F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()));\n\n"

"#define NGX_EXPORT_SERVICE_IOY_Y(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_IOY_Y, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_async_ioy_y $ AUX_NGX_IOY_Y F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> AUX_NGX.CUInt -> AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()));\n\n"

"#define NGX_EXPORT_HANDLER(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_HANDLER, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_handler $ AUX_NGX_HANDLER F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_DEF_HANDLER(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_Y_Y, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_def_handler $ AUX_NGX_Y_Y F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> AUX_NGX.Ptr AUX_NGX.CString -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_UNSAFE_HANDLER(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_UNSAFE_HANDLER, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_unsafe_handler $ AUX_NGX_UNSAFE_HANDLER F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> IO AUX_NGX.CUInt;\n\n"

"#define NGX_EXPORT_ASYNC_HANDLER(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_ASYNC_HANDLER, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_async_handler $ AUX_NGX_ASYNC_HANDLER F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()));\n\n"

"#define NGX_EXPORT_ASYNC_HANDLER_ON_REQ_BODY(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_ASYNC_HANDLER_RB, F, F) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_async_handler_rb $ AUX_NGX_ASYNC_HANDLER_RB F; \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> \\\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) -> \\\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()));\n\n"

"#define NGX_EXPORT_SERVICE_HOOK(F) \\\n"
"AUX_NGX_TYPECHECK(AUX_NGX_IOY_Y, F, (const . F)) \\\n"
"ngx_hs_ ## F = aux_ngx_hs_ioy_y_with_free $ AUX_NGX_IOY_Y (const . F); \\\n"
"foreign export ccall ngx_hs_ ## F :: \\\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> \\\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt -> "
"\\\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> \\\n"
"    IO AUX_NGX.CUInt;\n\n"

"{-# LANGUAGE ViewPatterns #-}\n\n"

"module NgxHaskellUserRuntime where\n\n"

"-- requires packages base, cpphs, bytestring, async, binary, monad-loops, unix"
"\n\n"

"import qualified Foreign.C as AUX_NGX\n"
"import qualified Foreign.Ptr as AUX_NGX\n"
"import qualified Foreign.StablePtr as AUX_NGX\n"
"import qualified Foreign.Storable as AUX_NGX\n"
"import qualified Foreign.Marshal.Alloc as AUX_NGX\n"
"import qualified Foreign.Marshal.Utils as AUX_NGX\n"
"import qualified System.IO.Error as AUX_NGX\n"
"import qualified System.Posix.IO as AUX_NGX\n"
"import qualified System.Posix.Types as AUX_NGX\n"
"import qualified System.Posix.Signals as AUX_NGX\n"
"import qualified System.Posix.Internals as AUX_NGX\n"
"import qualified Control.Monad as AUX_NGX\n"
"import qualified Control.Monad.Loops as AUX_NGX\n"
"import qualified Control.DeepSeq as AUX_NGX\n"
"import qualified Control.Exception as AUX_NGX\n"
"import qualified GHC.IO.Exception as AUX_NGX\n"
"import qualified GHC.IO.Device as AUX_NGX\n"
"import qualified Control.Concurrent.Async as AUX_NGX\n"
"import qualified Data.ByteString as AUX_NGX_BS\n"
"import qualified Data.ByteString.Unsafe as AUX_NGX_BS\n"
"import qualified Data.ByteString.Lazy as AUX_NGX_BSL\n"
"import qualified Data.ByteString.Lazy.Char8 as AUX_NGX_BSLC8\n"
"import qualified Data.Binary.Put as AUX_NGX\n\n"

"-- START OF USER HASKELL CODE\n"
);

const ngx_str_t  ngx_http_haskell_module_standalone_footer =
ngx_string(
"\n-- END OF USER HASKELL CODE\n\n"

"type AUX_NGX_ContentHandlerResult =\n"
"    (AUX_NGX_BSL.ByteString, AUX_NGX_BS.ByteString, Int)\n"
"type AUX_NGX_UnsafeContentHandlerResult =\n"
"    (AUX_NGX_BS.ByteString, AUX_NGX_BS.ByteString, Int)\n\n"

"data AUX_NGX_EXPORT = AUX_NGX_S_S (String -> String)\n"
"                    | AUX_NGX_S_SS (String -> String -> String)\n"
"                    | AUX_NGX_S_LS ([String] -> String)\n"
"                    | AUX_NGX_B_S (String -> Bool)\n"
"                    | AUX_NGX_B_SS (String -> String -> Bool)\n"
"                    | AUX_NGX_B_LS ([String] -> Bool)\n"
"                    | AUX_NGX_Y_Y (AUX_NGX_BS.ByteString ->\n"
"                          AUX_NGX_BSL.ByteString)\n"
"                    | AUX_NGX_B_Y (AUX_NGX_BS.ByteString -> Bool)\n"
"                    | AUX_NGX_IOY_Y (AUX_NGX_BS.ByteString -> Bool ->\n"
"                          IO AUX_NGX_BSL.ByteString)\n"
"                    | AUX_NGX_IOY_YY (AUX_NGX_BSL.ByteString ->\n"
"                          AUX_NGX_BS.ByteString -> IO AUX_NGX_BSL.ByteString)"
"\n"
"                    | AUX_NGX_HANDLER (AUX_NGX_BS.ByteString ->\n"
"                          AUX_NGX_ContentHandlerResult)\n"
"                    | AUX_NGX_UNSAFE_HANDLER (AUX_NGX_BS.ByteString ->\n"
"                          AUX_NGX_UnsafeContentHandlerResult)\n"
"                    | AUX_NGX_ASYNC_HANDLER (AUX_NGX_BS.ByteString ->\n"
"                          IO AUX_NGX_ContentHandlerResult)\n"
"                    | AUX_NGX_ASYNC_HANDLER_RB (AUX_NGX_BSL.ByteString ->\n"
"                          AUX_NGX_BS.ByteString ->\n"
"                          IO AUX_NGX_ContentHandlerResult)\n\n"

"instance Enum AUX_NGX_EXPORT where\n"
"    toEnum _ = AUX_NGX_S_S id    -- not used\n"
"    fromEnum (AUX_NGX_S_S _)              = 1\n"
"    fromEnum (AUX_NGX_S_SS _)             = 2\n"
"    fromEnum (AUX_NGX_S_LS _)             = 3\n"
"    fromEnum (AUX_NGX_B_S _)              = 4\n"
"    fromEnum (AUX_NGX_B_SS _)             = 5\n"
"    fromEnum (AUX_NGX_B_LS _)             = 6\n"
"    fromEnum (AUX_NGX_Y_Y _)              = 7\n"
"    fromEnum (AUX_NGX_B_Y _)              = 8\n"
"    fromEnum (AUX_NGX_IOY_Y _)            = 9\n"
"    fromEnum (AUX_NGX_IOY_YY _)           = 10\n"
"    fromEnum (AUX_NGX_HANDLER _)          = 11\n"
"    fromEnum (AUX_NGX_UNSAFE_HANDLER _)   = 12\n"
"    fromEnum (AUX_NGX_ASYNC_HANDLER _)    = 13\n"
"    fromEnum (AUX_NGX_ASYNC_HANDLER_RB _) = 14\n\n"

"aux_ngx_exportType :: AUX_NGX_EXPORT -> IO AUX_NGX.CInt\n"
"aux_ngx_exportType = return . fromIntegral . fromEnum\n\n"

"data AUX_NGX_STR_TYPE = AUX_NGX_STR_TYPE AUX_NGX.CSize AUX_NGX.CString\n\n"

"instance AUX_NGX.Storable AUX_NGX_STR_TYPE where\n"
"    alignment = const $ max (AUX_NGX.alignment (undefined :: AUX_NGX.CSize))\n"
"                            (AUX_NGX.alignment (undefined :: AUX_NGX.CString))"
"\n"
"    sizeOf = (2 *) . AUX_NGX.alignment   -- must always be correct for\n"
"                                         -- aligned struct ngx_str_t\n"
"    peek p = do\n"
"        n <- AUX_NGX.peekByteOff p 0\n"
"        s <- AUX_NGX.peekByteOff p $\n"
"            AUX_NGX.alignment (undefined :: AUX_NGX_STR_TYPE)\n"
"        return $ AUX_NGX_STR_TYPE n s\n"
"    poke p x@(AUX_NGX_STR_TYPE n s) = do\n"
"        AUX_NGX.poke (AUX_NGX.castPtr p) n\n"
"        AUX_NGX.poke (AUX_NGX.plusPtr p $ AUX_NGX.alignment x) s\n\n"

"data AUX_NGX_ServiceHookInterrupt = AUX_NGX_ServiceHookInterrupt\n\n"

"instance AUX_NGX.Exception AUX_NGX_ServiceHookInterrupt\n"
"instance Show AUX_NGX_ServiceHookInterrupt where\n"
"    show = const \"Service was interrupted by a service hook\"\n\n"

"aux_ngx_safeMallocBytes :: Int -> IO (AUX_NGX.Ptr a)\n"
"aux_ngx_safeMallocBytes =\n"
"    flip AUX_NGX.catchIOError (const $ return AUX_NGX.nullPtr) .\n"
"        AUX_NGX.mallocBytes\n"
"{-# INLINE aux_ngx_safeMallocBytes #-}\n\n"

"aux_ngx_safeNewCStringLen :: String -> IO AUX_NGX.CStringLen\n"
"aux_ngx_safeNewCStringLen =\n"
"    flip AUX_NGX.catchIOError (const $ return (AUX_NGX.nullPtr, -1)) .\n"
"        AUX_NGX.newCStringLen\n"
"{-# INLINE aux_ngx_safeNewCStringLen #-}\n\n"

"aux_ngx_peekNgxStringArrayLen :: (AUX_NGX.CStringLen -> IO a) ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int -> IO [a]\n"
"aux_ngx_peekNgxStringArrayLen f x = sequence .\n"
"    foldr (\\k ->\n"
"            ((AUX_NGX.peekElemOff x k >>=\n"
"                (\\(AUX_NGX_STR_TYPE (fromIntegral -> m) y) -> f (y, m))) :)\n"
"          ) [] . flip take [0 ..]\n"
"{-# SPECIALIZE INLINE aux_ngx_peekNgxStringArrayLen ::\n"
"    (AUX_NGX.CStringLen -> IO String) ->\n"
"        AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int -> IO [String] #-}\n"
"{-# SPECIALIZE INLINE aux_ngx_peekNgxStringArrayLen ::\n"
"    (AUX_NGX.CStringLen -> IO AUX_NGX_BS.ByteString) ->\n"
"        AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int -> IO [AUX_NGX_BS.ByteString] #-}"
"\n\n"

"aux_ngx_peekNgxStringArrayLenLS :: AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int ->\n"
"    IO [String]\n"
"aux_ngx_peekNgxStringArrayLenLS =\n"
"    aux_ngx_peekNgxStringArrayLen AUX_NGX.peekCStringLen\n\n"

"aux_ngx_peekNgxStringArrayLenY :: AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int ->\n"
"    IO AUX_NGX_BSL.ByteString\n"
"aux_ngx_peekNgxStringArrayLenY =\n"
"    (fmap AUX_NGX_BSL.fromChunks .) .\n"
"        aux_ngx_peekNgxStringArrayLen AUX_NGX_BS.unsafePackCStringLen\n\n"

"aux_ngx_pokeCStringLen :: AUX_NGX.Storable a =>\n"
"    AUX_NGX.CString -> a -> AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr a ->\n"
"    IO ()\n"
"aux_ngx_pokeCStringLen x n p s = AUX_NGX.poke p x >> AUX_NGX.poke s n\n"
"{-# SPECIALIZE INLINE aux_ngx_pokeCStringLen ::\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.Ptr AUX_NGX.CString ->\n"
"        AUX_NGX.Ptr AUX_NGX.CInt -> IO () #-}\n"
"{-# SPECIALIZE INLINE aux_ngx_pokeCStringLen ::\n"
"    AUX_NGX.CString -> AUX_NGX.CSize -> AUX_NGX.Ptr AUX_NGX.CString ->\n"
"        AUX_NGX.Ptr AUX_NGX.CSize -> IO () #-}\n\n"

"aux_ngx_toBuffers :: AUX_NGX_BSL.ByteString -> AUX_NGX.Ptr AUX_NGX_STR_TYPE ->"
"\n"
"    IO (AUX_NGX.Ptr AUX_NGX_STR_TYPE, Int)\n"
"aux_ngx_toBuffers (AUX_NGX_BSL.null -> True) _ =\n"
"    return (AUX_NGX.nullPtr, 0)\n"
"aux_ngx_toBuffers s p = do\n"
"    let n = AUX_NGX_BSL.foldlChunks (const . succ) 0 s\n"
"    if n == 1\n"
"        then do\n"
"            AUX_NGX_BS.unsafeUseAsCStringLen (head $ AUX_NGX_BSL.toChunks s) $"
"\n"
"                \\(x, fromIntegral -> l) ->\n"
"                    AUX_NGX.poke p $ AUX_NGX_STR_TYPE l x\n"
"            return (p, 1)\n"
"        else do\n"
"            t <- aux_ngx_safeMallocBytes $\n"
"                n * AUX_NGX.sizeOf (undefined :: AUX_NGX_STR_TYPE)\n"
"            if t == AUX_NGX.nullPtr\n"
"                then return (AUX_NGX.nullPtr, -1)\n"
"                else (,) t <$>\n"
"                        AUX_NGX_BSL.foldlChunks\n"
"                            (\\a c -> do\n"
"                                off <- a\n"
"                                AUX_NGX_BS.unsafeUseAsCStringLen c $\n"
"                                    \\(x, fromIntegral -> l) ->\n"
"                                        AUX_NGX.pokeElemOff t off $\n"
"                                            AUX_NGX_STR_TYPE l x\n"
"                                return $ off + 1\n"
"                            ) (return 0) s\n\n"

"aux_ngx_pokeLazyByteString :: AUX_NGX_BSL.ByteString ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) -> IO ()\n"
"aux_ngx_pokeLazyByteString s p pl spd = do\n"
"    (t, fromIntegral -> l) <- AUX_NGX.peek p >>= aux_ngx_toBuffers s\n"
"    AUX_NGX.when (l /= 1) (AUX_NGX.poke p t) >> AUX_NGX.poke pl l\n"
"    AUX_NGX.when (t /= AUX_NGX.nullPtr) $\n"
"        AUX_NGX.newStablePtr s >>= AUX_NGX.poke spd\n\n"

"aux_ngx_pokeContentTypeAndStatus :: AUX_NGX_BS.ByteString ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> AUX_NGX.CInt -> IO ()\n"
"aux_ngx_pokeContentTypeAndStatus ct pct plct pst st = do\n"
"    (sct, fromIntegral -> lct) <-\n"
"        AUX_NGX_BS.unsafeUseAsCStringLen ct return\n"
"    aux_ngx_pokeCStringLen sct lct pct plct >> AUX_NGX.poke pst st\n\n"

"aux_ngx_peekRequestBodyChunks :: AUX_NGX.Ptr AUX_NGX_STR_TYPE ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> Int -> IO AUX_NGX_BSL.ByteString\n"
"aux_ngx_peekRequestBodyChunks tmpf b m =\n"
"    if tmpf /= AUX_NGX.nullPtr\n"
"        then do\n"
"            c <- AUX_NGX.peek tmpf >>=\n"
"                (\\(AUX_NGX_STR_TYPE (fromIntegral -> l) s) ->\n"
"                    AUX_NGX.peekCStringLen (s, l)) >>=\n"
"                        AUX_NGX_BSL.readFile\n"
"            AUX_NGX_BSL.length c `seq` return c\n"
"        else aux_ngx_peekNgxStringArrayLenY b m\n\n"

"aux_ngx_pokeAsyncHandlerData :: AUX_NGX_BS.ByteString ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> AUX_NGX.CInt -> IO ()\n"
"aux_ngx_pokeAsyncHandlerData ct pct plct spct pst st = do\n"
"    aux_ngx_pokeContentTypeAndStatus ct pct plct pst st\n"
"    AUX_NGX.newStablePtr ct >>= AUX_NGX.poke spct\n\n"

"aux_ngx_safeHandler :: AUX_NGX.Ptr AUX_NGX.CString ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> IO AUX_NGX.CUInt -> IO AUX_NGX.CUInt\n"
"aux_ngx_safeHandler p pl = AUX_NGX.handle $ \\e -> do\n"
"    (x, fromIntegral -> l) <- aux_ngx_safeNewCStringLen $\n"
"        show (e :: AUX_NGX.SomeException)\n"
"    aux_ngx_pokeCStringLen x l p pl\n"
"    return 1\n\n"

"aux_ngx_safeYYHandler :: IO (AUX_NGX_BSL.ByteString, (AUX_NGX.CUInt, Bool)) ->"
"\n"
"    IO (AUX_NGX_BSL.ByteString, (AUX_NGX.CUInt, Bool))\n"
"aux_ngx_safeYYHandler = AUX_NGX.handle $ \\e ->\n"
"    return (AUX_NGX_BSLC8.pack $ show e,\n"
"            (case AUX_NGX.fromException e of\n"
"                Just AUX_NGX_ServiceHookInterrupt -> 2\n"
"                _ -> 1\n"
"            ,case AUX_NGX.asyncExceptionFromException e of\n"
"                Just AUX_NGX.ThreadKilled -> True\n"
"                _ -> False\n"
"            )\n"
"           )\n"
"{-# INLINE aux_ngx_safeYYHandler #-}\n\n"

"aux_ngx_isEINTR :: AUX_NGX.IOError -> Bool\n"
"aux_ngx_isEINTR =\n"
"    (Just ((\\(AUX_NGX.Errno i) -> i) AUX_NGX.eINTR) ==) . AUX_NGX.ioe_errno\n"
"{-# INLINE aux_ngx_isEINTR #-}\n\n"

"aux_ngx_hs_s_s :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_s_s (AUX_NGX_S_S f)\n"
"            x (fromIntegral -> n) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        (s, fromIntegral -> l) <- f <$> AUX_NGX.peekCStringLen (x, n)\n"
"                                    >>= AUX_NGX.newCStringLen\n"
"        aux_ngx_pokeCStringLen s l p pl\n"
"        return 0\n\n"

"aux_ngx_hs_s_ss :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_s_ss (AUX_NGX_S_SS f)\n"
"            x (fromIntegral -> n) y (fromIntegral -> m) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        (s, fromIntegral -> l) <- f <$> AUX_NGX.peekCStringLen (x, n)\n"
"                                    <*> AUX_NGX.peekCStringLen (y, m)\n"
"                                    >>= AUX_NGX.newCStringLen\n"
"        aux_ngx_pokeCStringLen s l p pl\n"
"        return 0\n\n"

"aux_ngx_hs_s_ls :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_s_ls (AUX_NGX_S_LS f)\n"
"            x (fromIntegral -> n) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        (s, fromIntegral -> l) <- f <$> aux_ngx_peekNgxStringArrayLenLS x n\n"
"                                    >>= AUX_NGX.newCStringLen\n"
"        aux_ngx_pokeCStringLen s l p pl\n"
"        return 0\n\n"

"aux_ngx_hs_y_y :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_y_y (AUX_NGX_Y_Y f)\n"
"            x (fromIntegral -> n) p pl spd = do\n"
"    (s, (r, _)) <- aux_ngx_safeYYHandler $ do\n"
"        s <- f <$> AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        fmap (flip (,) (0, False)) $ return AUX_NGX.$!! s\n"
"    aux_ngx_pokeLazyByteString s p pl spd\n"
"    return r\n\n"

"aux_ngx_hs_ioy_y_common :: (AUX_NGX.CStringLen -> IO AUX_NGX_BS.ByteString) ->"
"\n"
"    AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_ioy_y_common aux_ngx_pack (AUX_NGX_IOY_Y f)\n"
"            x (fromIntegral -> n) p pl spd = do\n"
"    (s, (r, _)) <- aux_ngx_safeYYHandler $ do\n"
"        s <- aux_ngx_pack (x, n) >>= flip f False\n"
"        fmap (flip (,) (0, False)) $ return AUX_NGX.$!! s\n"
"    aux_ngx_pokeLazyByteString s p pl spd\n"
"    return r\n\n"

"aux_ngx_hs_ioy_y :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_ioy_y =\n"
"    aux_ngx_hs_ioy_y_common AUX_NGX_BS.unsafePackCStringLen\n\n"

"aux_ngx_hs_ioy_y_with_free :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_ioy_y_with_free =\n"
"    aux_ngx_hs_ioy_y_common AUX_NGX_BS.unsafePackMallocCStringLen\n\n"

"aux_ngx_asyncIOFlag1b :: AUX_NGX_BS.ByteString\n"
"aux_ngx_asyncIOFlag1b =\n"
"    AUX_NGX_BSL.toStrict $ AUX_NGX.runPut $ AUX_NGX.putWord8 1\n\n"

"aux_ngx_asyncIOFlag8b :: AUX_NGX_BS.ByteString\n"
"aux_ngx_asyncIOFlag8b =\n"
"    AUX_NGX_BSL.toStrict $ AUX_NGX.runPut $ AUX_NGX.putWord64host 1\n\n"

"aux_ngx_asyncIOCommon :: IO (AUX_NGX_BSL.ByteString, Bool) ->\n"
"    AUX_NGX.CInt -> Bool -> AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> AUX_NGX.Ptr AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()))\n"
"aux_ngx_asyncIOCommon a (fromIntegral -> fd) efd p pl pr spd =\n"
"    AUX_NGX.async\n"
"    (do\n"
"        (s, (r, exiting)) <- aux_ngx_safeYYHandler $ do\n"
"            (s, exiting) <- a\n"
"            fmap (flip (,) (0, exiting)) $ return AUX_NGX.$!! s\n"
"        aux_ngx_pokeLazyByteString s p pl spd\n"
"        AUX_NGX.poke pr r\n"
"        if exiting\n"
"            then AUX_NGX.unless efd closeChannel\n"
"            else AUX_NGX.uninterruptibleMask_ $\n"
"                    if efd\n"
"                        then writeFlag8b\n"
"                        else writeFlag1b >> closeChannel\n"
"    ) >>= AUX_NGX.newStablePtr\n"
"    where writeBufN n s = AUX_NGX.void $\n"
"              AUX_NGX.iterateUntilM (>= n)\n"
"              (\\w -> (w +) <$>\n"
"                  AUX_NGX.fdWriteBuf fd (AUX_NGX.plusPtr s $ fromIntegral w)\n"
"                      (n - w)\n"
"                  `AUX_NGX.catchIOError`\n"
"                  (\\e -> return $ if aux_ngx_isEINTR e\n"
"                                      then 0\n"
"                                      else n\n"
"                  )\n"
"              ) 0\n"
"          writeFlag1b =\n"
"              AUX_NGX_BS.unsafeUseAsCString aux_ngx_asyncIOFlag1b $ writeBufN "
"1\n"
"          writeFlag8b =\n"
"              AUX_NGX_BS.unsafeUseAsCString aux_ngx_asyncIOFlag8b $ writeBufN "
"8\n"
"          closeChannel =\n"
"              AUX_NGX.closeFd fd `AUX_NGX.catchIOError` const (return ())\n\n"

"aux_ngx_hs_async_ioy_y :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt -> AUX_NGX.CUInt -> AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()))\n"
"aux_ngx_hs_async_ioy_y (AUX_NGX_IOY_Y f)\n"
"            x (fromIntegral -> n) fd (fromIntegral -> fdlk) active\n"
"            (AUX_NGX.toBool -> efd) (AUX_NGX.toBool -> fstRun) =\n"
"    aux_ngx_asyncIOCommon\n"
"    (do\n"
"        exiting <- if fstRun && fdlk /= -1\n"
"                       then snd <$>\n"
"                           AUX_NGX.iterateUntil ((True ==) . fst)\n"
"                           (aux_ngx_safeWaitToSetLock fdlk\n"
"                                (AUX_NGX.WriteLock, AUX_NGX.AbsoluteSeek,\n"
"                                     0, 0) >> return (True, False)\n"
"                           )\n"
"                           `AUX_NGX.catches`\n"
"                           [AUX_NGX.Handler $\n"
"                                return . flip (,) False . not . "
"aux_ngx_isEINTR\n"
"                           ,AUX_NGX.Handler $\n"
"                                return . (,) True . (== AUX_NGX.ThreadKilled)"
"\n"
"                           ]\n"
"                       else return False\n"
"        if exiting\n"
"            then return (AUX_NGX_BSL.empty, True)\n"
"            else do\n"
"                AUX_NGX.when fstRun $ AUX_NGX.poke active 1\n"
"                x' <- AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"                flip (,) False <$> f x' fstRun\n"
"    ) fd efd\n\n"

"aux_ngx_hs_async_ioy_yy :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> AUX_NGX.Ptr AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()))\n"
"aux_ngx_hs_async_ioy_yy (AUX_NGX_IOY_YY f)\n"
"            tmpf b (fromIntegral -> m) x (fromIntegral -> n)\n"
"            fd (AUX_NGX.toBool -> efd) =\n"
"    aux_ngx_asyncIOCommon\n"
"    (do\n"
"        b' <- aux_ngx_peekRequestBodyChunks tmpf b m\n"
"        x' <- AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        flip (,) False <$> f b' x'\n"
"    ) fd efd\n\n"

"aux_ngx_hs_async_handler :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()))\n"
"aux_ngx_hs_async_handler (AUX_NGX_ASYNC_HANDLER f)\n"
"            x (fromIntegral -> n) fd (AUX_NGX.toBool -> efd)\n"
"            pct plct spct pst =\n"
"    aux_ngx_asyncIOCommon\n"
"    (do\n"
"        x' <- AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        (s, ct, fromIntegral -> st) <- f x'\n"
"        (return AUX_NGX.$!! s) >>\n"
"            aux_ngx_pokeAsyncHandlerData ct pct plct spct pst st\n"
"        return (s, False)\n"
"    ) fd efd\n\n"

"aux_ngx_hs_async_handler_rb :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt -> AUX_NGX.CInt -> AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr AUX_NGX.CUInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO (AUX_NGX.StablePtr (AUX_NGX.Async ()))\n"
"aux_ngx_hs_async_handler_rb (AUX_NGX_ASYNC_HANDLER_RB f)\n"
"            tmpf b (fromIntegral -> m) x (fromIntegral -> n)\n"
"            fd (AUX_NGX.toBool -> efd)\n"
"            pct plct spct pst =\n"
"    aux_ngx_asyncIOCommon\n"
"    (do\n"
"        b' <- aux_ngx_peekRequestBodyChunks tmpf b m\n"
"        x' <- AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        (s, ct, fromIntegral -> st) <- f b' x'\n"
"        (return AUX_NGX.$!! s) >>\n"
"            aux_ngx_pokeAsyncHandlerData ct pct plct spct pst st\n"
"        return (s, False)\n"
"    ) fd efd\n\n"

"aux_ngx_hs_b_s :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_b_s (AUX_NGX_B_S f)\n"
"            x (fromIntegral -> n) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        r <- AUX_NGX.fromBool . f <$> AUX_NGX.peekCStringLen (x, n)\n"
"        aux_ngx_pokeCStringLen AUX_NGX.nullPtr 0 p pl\n"
"        return r\n\n"

"aux_ngx_hs_b_ss :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_b_ss (AUX_NGX_B_SS f)\n"
"            x (fromIntegral -> n) y (fromIntegral -> m) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        r <- (AUX_NGX.fromBool .) . f <$> AUX_NGX.peekCStringLen (x, n)\n"
"                                      <*> AUX_NGX.peekCStringLen (y, m)\n"
"        aux_ngx_pokeCStringLen AUX_NGX.nullPtr 0 p pl\n"
"        return r\n\n"

"aux_ngx_hs_b_ls :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.Ptr AUX_NGX_STR_TYPE -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_b_ls (AUX_NGX_B_LS f)\n"
"            x (fromIntegral -> n) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        r <- AUX_NGX.fromBool . f <$> aux_ngx_peekNgxStringArrayLenLS x n\n"
"        aux_ngx_pokeCStringLen AUX_NGX.nullPtr 0 p pl\n"
"        return r\n\n"

"aux_ngx_hs_b_y :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_b_y (AUX_NGX_B_Y f)\n"
"            x (fromIntegral -> n) p pl =\n"
"    aux_ngx_safeHandler p pl $ do\n"
"        r <- AUX_NGX.fromBool . f <$> AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        aux_ngx_pokeCStringLen AUX_NGX.nullPtr 0 p pl\n"
"        return r\n\n"

"aux_ngx_hs_handler :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BS.ByteString) ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_handler (AUX_NGX_HANDLER f)\n"
"            x (fromIntegral -> n) p pl pct plct spct pst spd =\n"
"    aux_ngx_safeHandler pct pst $ do\n"
"        (s, ct, fromIntegral -> st) <-\n"
"            f <$> AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        (return AUX_NGX.$!! s) >>\n"
"            aux_ngx_pokeContentTypeAndStatus ct pct plct pst st\n"
"        aux_ngx_pokeLazyByteString s p pl spd\n"
"        AUX_NGX.newStablePtr ct >>= AUX_NGX.poke spct\n"
"        return 0\n\n"

"aux_ngx_hs_def_handler :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr (AUX_NGX.Ptr AUX_NGX_STR_TYPE) -> AUX_NGX.Ptr AUX_NGX.CInt ->"
"\n"
"    AUX_NGX.Ptr AUX_NGX.CString ->\n"
"    AUX_NGX.Ptr (AUX_NGX.StablePtr AUX_NGX_BSL.ByteString) ->\n"
"    IO AUX_NGX.CUInt\n"
"aux_ngx_hs_def_handler (AUX_NGX_Y_Y f)\n"
"            x (fromIntegral -> n) p pl pe spd =\n"
"    aux_ngx_safeHandler pe pl $ do\n"
"        s <- f <$> AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        aux_ngx_pokeLazyByteString s p pl spd\n"
"        return 0\n\n"

"aux_ngx_hs_unsafe_handler :: AUX_NGX_EXPORT ->\n"
"    AUX_NGX.CString -> AUX_NGX.CInt ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr AUX_NGX.CString -> AUX_NGX.Ptr AUX_NGX.CSize ->\n"
"    AUX_NGX.Ptr AUX_NGX.CInt -> IO AUX_NGX.CUInt\n"
"aux_ngx_hs_unsafe_handler (AUX_NGX_UNSAFE_HANDLER f)\n"
"            x (fromIntegral -> n) p pl pct plct pst =\n"
"    aux_ngx_safeHandler pct pst $ do\n"
"        (s, ct, fromIntegral -> st) <-\n"
"            f <$> AUX_NGX_BS.unsafePackCStringLen (x, n)\n"
"        (return AUX_NGX.$!! s) >>\n"
"            aux_ngx_pokeContentTypeAndStatus ct pct plct pst st\n"
"        (t, fromIntegral -> l) <- AUX_NGX_BS.unsafeUseAsCStringLen s return\n"
"        aux_ngx_pokeCStringLen t l p pl\n"
"        return 0\n\n"

"{- SPLICE: safe version of waitToSetLock as defined in System.Posix.IO -}\n\n"

"foreign import ccall interruptible \"HsBase.h fcntl\"\n"
"    aux_ngx_safe_c_fcntl_lock :: AUX_NGX.CInt -> AUX_NGX.CInt ->\n"
"        AUX_NGX.Ptr AUX_NGX.CFLock -> IO AUX_NGX.CInt\n\n"

"aux_ngx_mode2Int :: AUX_NGX.SeekMode -> AUX_NGX.CShort\n"
"aux_ngx_mode2Int AUX_NGX.AbsoluteSeek = 0\n"
"aux_ngx_mode2Int AUX_NGX.RelativeSeek = 1\n"
"aux_ngx_mode2Int AUX_NGX.SeekFromEnd  = 2\n\n"

"aux_ngx_lockReq2Int :: AUX_NGX.LockRequest -> AUX_NGX.CShort\n"
"aux_ngx_lockReq2Int AUX_NGX.ReadLock  = 0\n"
"aux_ngx_lockReq2Int AUX_NGX.WriteLock = 1\n"
"aux_ngx_lockReq2Int AUX_NGX.Unlock    = 2\n\n"

"aux_ngx_allocaLock :: AUX_NGX.FileLock ->\n"
"    (AUX_NGX.Ptr AUX_NGX.CFLock -> IO a) -> IO a\n"
"aux_ngx_allocaLock (lockreq, mode, start, len) io =\n"
"    AUX_NGX.allocaBytes 32 $ \\p -> do\n"
"        (`AUX_NGX.pokeByteOff`  0) p (aux_ngx_lockReq2Int lockreq)\n"
"        (`AUX_NGX.pokeByteOff`  2) p (aux_ngx_mode2Int mode)\n"
"        (`AUX_NGX.pokeByteOff`  8) p start\n"
"        (`AUX_NGX.pokeByteOff` 16) p len\n"
"        io p\n\n"

"aux_ngx_safeWaitToSetLock :: AUX_NGX.Fd -> AUX_NGX.FileLock -> IO ()\n"
"aux_ngx_safeWaitToSetLock (AUX_NGX.Fd fd) lock = aux_ngx_allocaLock lock $\n"
"    \\p_flock -> AUX_NGX.throwErrnoIfMinus1_ \"safeWaitToSetLock\" $\n"
"        aux_ngx_safe_c_fcntl_lock fd 7 p_flock\n\n"

"{- SPLICE: END -}\n\n"

"foreign export ccall ngxExportInstallSignalHandler :: IO ()\n"
"ngxExportInstallSignalHandler :: IO ()\n"
"ngxExportInstallSignalHandler = AUX_NGX.void $\n"
"    AUX_NGX.installHandler AUX_NGX.keyboardSignal AUX_NGX.Ignore Nothing\n\n"

"foreign export ccall ngxExportTerminateTask ::\n"
"    AUX_NGX.StablePtr (AUX_NGX.Async ()) -> IO ()\n"
"ngxExportTerminateTask ::\n"
"    AUX_NGX.StablePtr (AUX_NGX.Async ()) -> IO ()\n"
"ngxExportTerminateTask =\n"
"    AUX_NGX.deRefStablePtr AUX_NGX.>=> AUX_NGX.cancel\n\n"

"foreign export ccall ngxExportServiceHookInterrupt ::\n"
"    AUX_NGX.StablePtr (AUX_NGX.Async ()) -> IO ()\n"
"ngxExportServiceHookInterrupt ::\n"
"    AUX_NGX.StablePtr (AUX_NGX.Async ()) -> IO ()\n"
"ngxExportServiceHookInterrupt =\n"
"    AUX_NGX.deRefStablePtr AUX_NGX.>=>\n"
"        flip AUX_NGX.throwTo AUX_NGX_ServiceHookInterrupt .\n"
"            AUX_NGX.asyncThreadId\n\n"
);

